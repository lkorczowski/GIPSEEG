
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ACSTP</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-12-11"><meta name="DC.source" content="ACSTP.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">ACSTP loop Algorithm</a></li><li><a href="#6">find best Pz and PLOT</a></li><li><a href="#8">%%%%%%%%%%%% COMPUTE CSTP FILTERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [Xhat ACSTPstruct]=ACSTP(EEG,ACSTPoptions)
</pre><pre class="codeinput"><span class="comment">%%%% Adaptive Common Spatio-Temporal Pattern</span>
<span class="comment">% [Xhat ACSTPstruct]=ACSTP(EEG,ACSTPoptions)</span>
<span class="comment">%</span>
<span class="comment">% Compute the Adaptive Common Spatio-Temporal Pattern Filter (ACSTP) from the</span>
<span class="comment">% continuous recording EEG.</span>
<span class="comment">%</span>
<span class="comment">% The estimated ERP epochs Xhat are returned such as :</span>
<span class="comment">% for X the EEG epochs with corrected latencies and with weights W, the ACSTP filter, does:</span>
<span class="comment">% Xhat(:,:,k)=As*Bs'*W(k)*X(:,:,k)*Bt*At';</span>
<span class="comment">%</span>
<span class="comment">% With the output ACSTPstruct, you can manually apply the filter on the EEG</span>
<span class="comment">% such as :</span>
<span class="comment">% TriggerCorrected=CorrectLatency(EEG.Trigger,ACSTPstruct.Latency); % apply latency correction</span>
<span class="comment">% X=epoch_p300(EEG.Channels,TriggerCorrected,ACSTPstruct.Epoch_size); % extract the epochs</span>
<span class="comment">% Xw=applyWeights(X,ACSTPstruct.Weights); %apply the weights</span>
<span class="comment">% Xhat=applyCSTP(Xw,ACSTPstruct.Bs,ACSTPstruct.Bt,ACSTPstruct.As,ACSTPstruct.At,EEG.EpochClass); %apply the ACSTP</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%%%% INPUTS :</span>
<span class="comment">% ------</span>
<span class="comment">% EEG is a structure with</span>
<span class="comment">%              Fs: scalar (sample rate in Hz)</span>
<span class="comment">%         Trigger: [nb samples x1 ] Trigger channel of '0' with '1' at the start</span>
<span class="comment">%                   of each sweep. There are [nb epochs] '1'.</span>
<span class="comment">%      EpochClass: [nb epochs x1] class of the sweeps (0 for Non-TARGET, 1</span>
<span class="comment">%                   for TARGET).</span>
<span class="comment">%        Channels: [nb samples x nb channels] preprocessed EEG recordings</span>
<span class="comment">%   NoiseTrigger*: the equivalent of Trigger but for the sweep of the noise.</span>
<span class="comment">%                   By default, it takes the same.</span>
<span class="comment">% ElectrodesName*: {1 x nb channels} the names of the electrodes (usefull</span>
<span class="comment">%                  only in case of plot, i.e. ACSTPoptions.DISPLAY=true)</span>
<span class="comment">%</span>
<span class="comment">% ACSTPoptions is a structure with</span>
<span class="comment">%      Epoch_size: scalar, the length of the epoch window (in samples)</span>
<span class="comment">% LatencyCorr_max: scalar, the maximum of samples for the latency</span>
<span class="comment">%                   correction. Set 0 to disable the Latency correction.</span>
<span class="comment">% Mask_Electrodes: vector of the selectionned electrodes. Usefull for the</span>
<span class="comment">%                  automatic subspace selection (BestPz) and latency</span>
<span class="comment">%                  correction (Latency).</span>
<span class="comment">%       Mask_Time: vector of the selectionned sample. Usefull for the</span>
<span class="comment">%                  automatic subspace selection (BestPz) and latency</span>
<span class="comment">%                  correction (Latency).</span>
<span class="comment">% MaxIterLatency*: scalar, the maximum iteration allowed to compute the</span>
<span class="comment">%                   latency correction. Default: 10.</span>
<span class="comment">%    SubspaceDim*: vector, containing all the subspace dimension (&lt;nb electrodes)</span>
<span class="comment">%                  to test in descent order.</span>
<span class="comment">%                   By default, it is equal to (nb_channels:-1:(nb_channels/2))</span>
<span class="comment">%computeClassLat*: vector, containing all the class tag in which you want</span>
<span class="comment">%                   to compute the latency correction. By default, it</span>
<span class="comment">%                   computes it for all classes but it could be long (for</span>
<span class="comment">%                   instance you can skip the non-target).</span>
<span class="comment">%        Weights*: Default: true.</span>
<span class="comment">%                  option1(given) [nb epochs x1] vector, containing the weights for each</span>
<span class="comment">%                   epoch if it is computed from an external function.</span>
<span class="comment">%                  option2 (true/false) boolean. If true (default) the ACSTP compute the</span>
<span class="comment">%                   weight for each epoch. If false, the weights are</span>
<span class="comment">%                   desactivated (i.e. set to 1).</span>
<span class="comment">%        overlap*: Default: true (1). If set to 0, it will consider that</span>
<span class="comment">%                   the epochs are not overlapping and it will compute the standard</span>
<span class="comment">%                   ensemble average. If the window of your epochs is big (&gt;1024 samples), it could be</span>
<span class="comment">%                   also interesting to disable this function to speed up the process.</span>
<span class="comment">%        DISPLAY*: Boolean, should the comparative result between the arithmetic ensemble</span>
<span class="comment">%                   average and the ACSTP should be display at the end. Default: false.</span>
<span class="comment">%</span>
<span class="comment">%   *optional</span>
<span class="comment">%</span>
<span class="comment">%%%% OUTPUT :</span>
<span class="comment">% ------</span>
<span class="comment">% Xhat with corrected latencies, weighted and filtered</span>
<span class="comment">% ACSTPstruct is a structure with</span>
<span class="comment">%              EA: the ensemble average before ACSTP</span>
<span class="comment">%          EAcstp: the ensemble average corrected with latencies, weighted</span>
<span class="comment">%                   and filtered + with the effect of overlapping</span>
<span class="comment">%                   correction</span>
<span class="comment">%     As Bs Bt At: such as Xhat(:,:,k)=As{indClass}*Bs{indClass}'*W(k)*X(:,:,k)*Bt{indClass}*At{indClass}'</span>
<span class="comment">%                   Each filter is a cell containing a matrix filter for</span>
<span class="comment">%                   each class</span>
<span class="comment">%           Class: The tag and the order in which the filter are sorted</span>
<span class="comment">%          BestPz: Orders of the best subspace for the ACSTP for the given</span>
<span class="comment">%                  Class</span>
<span class="comment">%         Weights: [nb epochs x1] the weights of each epoch</span>
<span class="comment">%         Latency: [nb epochs x1] the corrected offset of each epoch</span>
<span class="comment">%      Epoch_size: scalar, the length of the epoch window (in samples)</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">% *** History: 11-Nov-2015</span>
<span class="comment">% *** Author: Louis KORCZOWSKI, GIPSA-Lab, 2015</span>
<span class="comment">% *** Related work: M. CONGEDO, L. KORCZOWSKI, A. DELORME, F. LOPES DA SILVA "Spatio-Temporal Common Pattern a Reference Companion Method for ERP Analysis" (submitted)</span>
<span class="comment">%</span>
<span class="comment">% see also : ACSTPshow, script_ACSTP_test</span>

Xhat=[];
ACSTPstruct=struct;
EEG.Channels=double(EEG.Channels);
<span class="keyword">if</span> ~isfield(ACSTPoptions,<span class="string">'DISPLAY'</span>)
    DISPLAY=0; <span class="comment">%put '1' to plot the results at the end of the computation or '0' to not.</span>
<span class="keyword">else</span>
    DISPLAY=ACSTPoptions.DISPLAY;
<span class="keyword">end</span>
<span class="keyword">if</span> ~isfield(ACSTPoptions,<span class="string">'overlap'</span>)
    ACSTPoptions.overlap=1;
<span class="keyword">end</span>
DISPLAYtime=0;<span class="comment">%set on for debug (optimization)</span>
<span class="keyword">if</span>( DISPLAYtime) tic; <span class="keyword">end</span>
<span class="comment">%%%%%%%%%%%%%%%%%% INPUT EXTRACTIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%check if the row are the electrodes and the columns are the samples</span>
<span class="keyword">if</span> size(EEG.Channels,1)&gt;size(EEG.Channels,2),EEG.Channels=EEG.Channels';<span class="keyword">end</span>


<span class="keyword">if</span> isfield(EEG,<span class="string">'NoiseTrigger'</span>),NoiseTrigger=EEG.NoiseTrigger;<span class="keyword">else</span> NoiseTrigger=[];<span class="keyword">end</span>

<span class="keyword">if</span> (size(EEG.EpochClass,1)==1),EEG.EpochClass=EEG.EpochClass';<span class="keyword">end</span> <span class="comment">%transpose vector if necessary</span>
<span class="keyword">if</span> (size(EEG.Trigger,1)==1),EEG.Trigger=EEG.Trigger';<span class="keyword">end</span> <span class="comment">%transpose vector if necessary</span>


<span class="comment">%Check if the EEG INPUTS are correct</span>
<span class="keyword">if</span> size(EEG.Channels,2)&lt;size(EEG.Channels,1)
    error([<span class="string">'EEG INPUT ERROR1: the temporal dimension of EEG.Channels is smaller than the spatial dimension.'</span> <span class="keyword">...</span>
        <span class="string">' Please check that EEG.Channels'' size is [nb samples x nb channels].'</span> ]);
<span class="keyword">end</span>

<span class="comment">% check EEG.Trigger Channel</span>
<span class="keyword">if</span> ~(size(EEG.Channels,2)==length(EEG.Trigger))
    warning(<span class="string">'ACSTP WARNING2: Size of EEG.Trigger not equals to nb samples of EEG.Channels'</span>)
    <span class="keyword">if</span> length(EEG.Trigger)==length(EEG.EpochClass)
        <span class="comment">%we assume that EEG.Trigger gives the position of the EEG.EpochClass instead of</span>
        <span class="comment">%being a trigger channel at the sample rate EEG.Fs</span>
        tmp=zeros(size(EEG.Channels,2),1);
        tmp(EEG.Trigger)=1;
        EEG.Trigger=tmp;
        clear <span class="string">tmp</span>
        warning(<span class="string">'EEG.Trigger has been assumed to be the EEG.EpochClass locations instead of a trigger channel at the sample rate EEG.Fs'</span>)
    <span class="keyword">else</span>
        error(<span class="string">'ACSTP ERROR3: EEG INPUT ERROR.'</span>)

    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% check NoiseTrigger Channel (if exist)</span>
<span class="keyword">if</span> ~isempty(NoiseTrigger)
    <span class="keyword">if</span> ~(size(EEG.Channels,2)==length(NoiseTrigger))
        warning(<span class="string">'ACSTP WARNING2b: Size of EEG.NoiseTrigger not equals to nb samples of EEG.Channels'</span>)
        <span class="comment">%we assume that NoiseTrigger gives the position of the EEG.EpochClass instead of</span>
        <span class="comment">%being a trigger channel at the sample rate EEG.Fs</span>
        tmp=zeros(size(EEG.Channels,2),1);
        tmp(NoiseTrigger)=1;
        NoiseTrigger=tmp;
        clear <span class="string">tmp</span>
        warning(<span class="string">'EEG.NoiseTrigger has been assumed to be the EEG.EpochClass locations instead of a trigger channel at the sample rate EEG.Fs'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">%%%%%%%%%%%%%%%%%% CSTP PARAMETERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>


<span class="keyword">if</span> nargin&lt;2
    Window=1*EEG.Fs; <span class="comment">%(11) the sweeps window will be 1s</span>
    Delays=4; <span class="comment">%(12) +/- nb shifted samples allowed for the jitter correction</span>
    winElec=[7,9,10,11,12,13,14,15,16]; <span class="comment">%(13)* electrodes used for latency calculation and Pz selection</span>
    <span class="comment">% exemple: Cz(7),P7(9),P3(10),Pz(11),P4(12),P8(13),O1(14),Oz(15),O2(16)</span>
    winTime=[floor((0.05)*128):ceil((0.550)*128)]; <span class="comment">%(14)* time window (in sample) used for latency calculation and Pz selection</span>
    <span class="comment">% exemple: 50ms to 550ms</span>
<span class="keyword">else</span>
    Window=ACSTPoptions.Epoch_size;
    <span class="keyword">if</span> isfield(ACSTPoptions,<span class="string">'LatencyCorr_max'</span>)
        Delays=ACSTPoptions.LatencyCorr_max;
        <span class="keyword">if</span> isempty(Delays)
            Delays=0;
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        Delays=0;
    <span class="keyword">end</span>
    <span class="keyword">if</span> ~isfield(ACSTPoptions,<span class="string">'Mask_Electrodes'</span>)
        winElec=1:size(EEG.Channels,1);<span class="comment">%put all electrodes</span>
    <span class="keyword">elseif</span> isempty(ACSTPoptions.Mask_Electrodes)
        winElec=1:size(EEG.Channels,1);<span class="comment">%put all electrodes</span>
    <span class="keyword">else</span>
        winElec=ACSTPoptions.Mask_Electrodes;
    <span class="keyword">end</span>

    <span class="keyword">if</span> ~isfield(ACSTPoptions,<span class="string">'Mask_Time'</span>)
        winElec=1:Window;<span class="comment">%put all samples</span>
    <span class="keyword">elseif</span> isempty(ACSTPoptions.Mask_Time)
        winElec=1:Window;<span class="comment">%put all samples</span>

    <span class="keyword">else</span>
        winTime=ACSTPoptions.Mask_Time;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%Check if the ACSTP INPUTS are correct</span>
<span class="keyword">if</span> any(find(EEG.Trigger)+Window-1&gt;size(EEG.Channels,2))
    error(<span class="string">'ACSTP ERROR4: ACSTP INPUT ERROR. The size of the epochs choosen in ACSTPoptions.Epoch_size is too big for the last event in EEG.Trigger.'</span>);
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(NoiseTrigger)
    <span class="keyword">if</span> any(find(NoiseTrigger)+Window&gt;size(EEG.Channels,2))
        error(<span class="string">'ACSTP ERROR4b: ACSTP INPUT ERROR. The size of the epochs choosen in ACSTPoptions.Epoch_size is too big for the last event in EEG.NoiseTrigger.'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> any(find(EEG.Trigger)+Window+Delays-1&gt;size(EEG.Channels,2))
    error(<span class="string">'ACSTP ERROR5: ACSTP INPUT ERROR. The delays choosen in ACSTPoptions.LatencyCorr_max is too big for the last event in EEG.Trigger.'</span>);

<span class="keyword">end</span>
<span class="keyword">if</span> any(find(EEG.Trigger)-Delays&lt;1)
    error(<span class="string">'ACSTP ERROR6: ACSTP INPUT ERROR. The delays choosen in ACSTPoptions.LatencyCorr_max is too big for the first event in EEG.Trigger.'</span>);

<span class="keyword">end</span>
<span class="keyword">if</span> any(max(winElec)&gt;size(EEG.Channels,1))
    error(<span class="string">'ACSTP ERROR7: ACSTP INPUT ERROR. ACSTPoptions.Mask_Electrodes incorrect'</span>);

<span class="keyword">end</span>
<span class="keyword">if</span> any(max(winTime)&gt;Window)
    error(<span class="string">'ACSTP ERROR8: ACSTP INPUT ERROR. ACSTPoptions.Mask_Time incorrect'</span>);

<span class="keyword">end</span>
<span class="comment">%%%%%%% ADDITIONNALS STRUCTURES FOR ACSTP (no user input needed)%%%%%%%%%%%</span>
WindowB=Window+2*Delays;
offset=-Delays;
[Xall]=epoch_p300(EEG.Channels,EEG.Trigger,WindowB,offset); <span class="comment">%prepare epoch for full window+latency</span>
<span class="keyword">if</span> ~isfield(ACSTPoptions,<span class="string">'MaxIterLatency'</span>)
    maxIter_Latcor=10;
<span class="keyword">else</span>
    maxIter_Latcor=ACSTPoptions.MaxIterLatency
<span class="keyword">end</span>
<span class="keyword">if</span> ~isfield(ACSTPoptions,<span class="string">'SubspaceDim'</span>)
    Pzfs=[size(Xall,1):-1:size(Xall,1)/2];<span class="comment">%choose the screening of the Pz</span>
<span class="keyword">else</span>
    <span class="keyword">if</span> isempty(ACSTPoptions.SubspaceDim)
        Pzfs=[size(Xall,1):-1:size(Xall,1)/2];<span class="comment">%choose the screening of the Pz</span>
    <span class="keyword">elseif</span> max(ACSTPoptions.SubspaceDim)&gt;size(EEG.Channels,1)
        error(<span class="string">'ACSTP ERROR9: ACSTP INPUT ERROR. The subspace dimension(s) choosen in ACSTPoptions.SubspaceDim is/are greater than the number of electrodes.'</span>);
    <span class="keyword">elseif</span> min(ACSTPoptions.SubspaceDim)&lt;1
        error(<span class="string">'ACSTP ERROR9: ACSTP INPUT ERROR. The subspace dimension(s) choosen in ACSTPoptions.SubspaceDim is/are smaller than 1.'</span>);
    <span class="keyword">else</span>
        Pzfs=ACSTPoptions.SubspaceDim;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%{
</span><span class="comment">%the constant offset has been desactivated. If you'll like to add an
</span><span class="comment">offset, please consider modifying EEG.Trigger as well as Epoch_size and Mask_Time
</span><span class="comment">accordingly in ACSTPoptions.
</span><span class="comment">
</span><span class="comment">if ~isfield(ACSTPoptions,'EpochsOffset')
</span><span class="comment">    EpochsOffset=0;%offset has been set to zero
</span><span class="comment">else
</span><span class="comment">    EpochsOffset=ACSTPoptions.EpochsOffset;
</span><span class="comment">    disp(['ACSTP INFO: The epochs will be with an offset of: ' num2str(EpochsOffset) ' samples.']);
</span><span class="comment">    if (find(EEG.Trigger,1)-Delays+EpochsOffset&lt;1)
</span><span class="comment">        disp('ACSTP ERROR9: ACSTP INPUT ERROR. ACSTPoptions.EpochsOffset is too big for the first event in EEG.Trigger.');
</span><span class="comment">    end
</span><span class="comment">end
</span><span class="comment">%}
</span>
<span class="comment">% NOT GOOD what if computeClassLat is empty ????</span>
<span class="keyword">if</span> Delays&gt;0
    <span class="keyword">if</span> ~isfield(ACSTPoptions,<span class="string">'computeClassLat'</span>)
        ClassLat=unique(EEG.EpochClass);<span class="comment">%all the classes</span>
        disp([<span class="string">'ACSTP INFO: Latencies will be computed for class(es): '</span> num2str(ClassLat') <span class="string">'.'</span>]);
        disp(<span class="string">'ACSTP INFO: Please consider only classes that need Latency correction to speed up the procedure.'</span>);
        disp( <span class="string">'ACSTP INFO: See setting ACSTPoptions.computeClassLat'</span>);

    <span class="keyword">elseif</span> isfield(ACSTPoptions,<span class="string">'computeClassLat'</span>)
        ClassLat=ACSTPoptions.computeClassLat;
        disp([<span class="string">'ACSTP INFO: Latencies will be computed only for class(es): '</span> num2str(ClassLat)]);

    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% CHECK the Weights' estimation (true/false/given).</span>
<span class="keyword">if</span> ~isfield(ACSTPoptions,<span class="string">'Weights'</span>) <span class="comment">% true (default)</span>
    ComputeWeights=1; <span class="comment">%ACSTP will estimate the Weights</span>
    disp([<span class="string">'ACSTP INFO: Weights will be computed: '</span> num2str(ComputeWeights) <span class="string">' (1=true/0=false)'</span>]);
<span class="keyword">else</span>
    <span class="keyword">if</span>(length(ACSTPoptions.Weights)==length(EEG.EpochClass)) <span class="comment">%given</span>
        ComputeWeights=0; <span class="comment">%ACSTP will NOT estimate the Weights</span>
        Weights=ACSTPoptions.Weights;
        warning([<span class="string">'ACSTP WARNING10: ACSTP INPUT WARNING. ACSTPoptions.Weights has been given and won''t be computed.'</span><span class="keyword">...</span>
            <span class="string">' Please check carefully your weights to avoid a scaling issue in output of the CSTP.'</span>]);
    <span class="keyword">elseif</span>(length(ACSTPoptions.Weights)==1) <span class="comment">%set true/false</span>
        ComputeWeights=ACSTPoptions.Weights;<span class="comment">%ACSTP does(true)/doesn't(false) estimate the Weights</span>
        disp([<span class="string">'ACSTP INFO: Weights will be computed: '</span> num2str(ComputeWeights) <span class="string">' (1=true/0=false)'</span>]);
    <span class="keyword">else</span> <span class="comment">%wrong size</span>
        error(<span class="string">'ACSTP ERROR11: ACSTP INPUT ERROR. ACSTPoptions.Weights size incorrect'</span>);
    <span class="keyword">end</span>

<span class="keyword">end</span>
<span class="keyword">if</span> (~exist(<span class="string">'Weights'</span>,<span class="string">'var'</span>) &amp;&amp; ~ComputeWeights) <span class="comment">%if Weights estimation false</span>
    Weights=ones(length(EEG.EpochClass),1);
<span class="keyword">end</span>
</pre><h2>ACSTP loop Algorithm<a name="3"></a></h2><pre class="codeinput">disp([<span class="string">'ACSTP INFO: Latency estimation: '</span> num2str(~(Delays==0)) <span class="string">' (1=activated/0=disabled)'</span>]);

<span class="comment">% Heuristic criterion for the Latency convergence:</span>
CriteriaConvLatencies=1/length(find(EEG.EpochClass))*Delays; <span class="comment">%nb latencies correction allowed for convergence.</span>


[ACSTPstruct.EA]=EnsembleAverage(EEG.Channels,EEG.EpochClass,EEG.Trigger,Window);

<span class="comment">%EEG.EpochClass=ones(size(EEG.EpochClass));</span>
[Xbarz Class]=meanOverlap(EEG.Channels,EEG.Trigger,Window,EEG.EpochClass,[],ACSTPoptions.overlap);<span class="comment">%estimate the arithmetic mean (0.10)</span>
Output{1}=Xbarz; <span class="comment">%save the AEA for future visualization</span>
<span class="keyword">if</span>(DISPLAYtime) dtime=[<span class="string">' t('</span> num2str(toc) <span class="string">')'</span>]; <span class="keyword">else</span> dtime=<span class="string">''</span>; <span class="keyword">end</span>
disp(([<span class="string">'COMPUTE ACSTP... STATE20CHAR         '</span> dtime]))
printCurrentState([<span class="string">'START               '</span> dtime])
iter=1;<span class="comment">%for each iteration, a Pz</span>
<span class="keyword">for</span> Pzf=Pzfs;
</pre><pre class="codeinput">    <span class="comment">%%(A.1) #################### DATA PREPARATION ####################</span>
    X=epoch_p300(EEG.Channels,EEG.Trigger,Window); <span class="comment">%get epochs</span>

    <span class="keyword">if</span> ~isempty(NoiseTrigger)
        Xnoise=epoch_p300(EEG.Channels,NoiseTrigger,Window);
    <span class="keyword">else</span>
        Xnoise=X;
    <span class="keyword">end</span>

    <span class="comment">%if needed, we can estimate the noise covariance from differents epochs</span>
    <span class="comment">%(e.g. resting state or randomly selected epochs)</span>


    <span class="comment">%%(A.2) #################### LATENCY INITIALIZATION ####################</span>

    LatencyCorrection(:,iter)=zeros(length(EEG.EpochClass),1); <span class="comment">%initialization latency at zero</span>

    <span class="comment">%%(A.3) #################### WEIGHTS INITIALIZATION ####################</span>
    <span class="keyword">if</span> (ComputeWeights)
        Weights=WeightsEstimation(X,EEG.EpochClass);
    <span class="keyword">end</span>

    <span class="comment">%%(A.4) #################### Xbarz INITIALIZATION ####################</span>

    [Xbarz Class]=meanOverlap(EEG.Channels,EEG.Trigger,Window,EEG.EpochClass,Weights,ACSTPoptions.overlap);

    <span class="keyword">if</span>(DISPLAYtime) dtime=[<span class="string">' t('</span> num2str(toc) <span class="string">')'</span>]; <span class="keyword">else</span> dtime=<span class="string">''</span>; <span class="keyword">end</span>
    <span class="comment">%%(B) #################### ACSTP Initialization ####################</span>
    printCurrentState([<span class="string">'Pzf '</span> num2str(Pzf) <span class="string">'ACSTP          '</span> dtime])
    [Bs Bt As At Class eigV]=CSTP(X,EEG.EpochClass,Xbarz,Weights,winElec,winTime,Pzf,Xnoise);

    <span class="comment">%%(3) #################### Filtered Ensemble Average Initialization ####################</span>
    Zbarz{iter}=applyCSTP(Xbarz,Bs,Bt,As,At,Class);

    Output{2}{iter}=Zbarz{iter}; <span class="comment">%save after CSTP (initialized)</span>
    Output{3}{iter}={Bs Bt As At};<span class="comment">%save CSTP (initialized)</span>

    <span class="keyword">if</span>(DISPLAYtime) dtime=[<span class="string">' t('</span> num2str(toc) <span class="string">')'</span>]; <span class="keyword">else</span> dtime=<span class="string">''</span>; <span class="keyword">end</span>
    printCurrentState([<span class="string">'Pzf '</span> num2str(Pzf) <span class="string">'WEIGHT         '</span> dtime])

    <span class="comment">%%(3) #################### WEIGHTS ESTIMATION ####################</span>
    <span class="keyword">if</span> (ComputeWeights)
        Weights=WeightsEstimation(X,EEG.EpochClass,Bs,Bt,As,At);
    <span class="keyword">end</span>

    <span class="comment">%%(4) #################### LATENCY CORRECTION LOOP ####################</span>
    <span class="keyword">if</span> Delays&gt;0 <span class="comment">%ONLY IF THE DELAYS NEED TO BE COMPUTED</span>
        <span class="keyword">for</span> indCl=1:length(ClassLat)
            class_for_lat=ClassLat(indCl);
            classLat_indices=(EEG.EpochClass==class_for_lat);<span class="comment">%just compute latencies for class target</span>
            tempoLatency=[];
            STOPlat=1;
            iterLat=1;
            <span class="keyword">if</span>(DISPLAYtime) dtime=[<span class="string">' t('</span> num2str(toc) <span class="string">')'</span>]; <span class="keyword">else</span> dtime=<span class="string">''</span>; <span class="keyword">end</span>
            printCurrentState([<span class="string">'Pzf '</span> num2str(Pzf) <span class="string">'LATEN'</span> num2str(class_for_lat) <span class="string">'         '</span> dtime])

            LatencyCorrection(classLat_indices,iter)=zeros(size(LatencyCorrection(classLat_indices,iter))); <span class="comment">%initialize latencies</span>
            <span class="keyword">while</span> STOPlat <span class="comment">%converge criteria</span>

                [tempoLatency Crit_Trace]=LatencyEstimation(Xall(:,:,classLat_indices),X(:,:,classLat_indices),EEG.EpochClass(classLat_indices),Weights(classLat_indices),Bs(end),Bt(end),As(end),Bt(end),winElec,winTime);

                Conv(iter,iterLat)=ConvergenceLatencies(tempoLatency,LatencyCorrection(classLat_indices,iter));
                <span class="keyword">if</span> (iterLat&gt;1 &amp;&amp; Conv(iter,iterLat)&lt;CriteriaConvLatencies) || iterLat&gt;=maxIter_Latcor
                    STOPlat=0;
                <span class="keyword">end</span>
                LatencyCorrection(classLat_indices,iter)=tempoLatency;
                TriggerCorrected=CorrectLatency(EEG.Trigger,LatencyCorrection(:,iter));
                X=epoch_p300(EEG.Channels,TriggerCorrected,Window);
                iterLat=iterLat+1;

            <span class="keyword">end</span>

        <span class="keyword">end</span>


        <span class="comment">%%(4) #################### CORRECT LATENCIES ####################</span>
        TriggerCorrected=CorrectLatency(EEG.Trigger,LatencyCorrection(:,iter));
        X=epoch_p300(EEG.Channels,TriggerCorrected,Window);

        [Xbarz Class]=meanOverlap(EEG.Channels,TriggerCorrected,Window,EEG.EpochClass,Weights,ACSTPoptions.overlap);

        <span class="comment">% Xbarz is then the EAE averaged with weighted epochs and with</span>
        <span class="comment">% corrected lattencies</span>

        <span class="keyword">if</span>(DISPLAYtime) dtime=[<span class="string">' t('</span> num2str(toc) <span class="string">')'</span>]; <span class="keyword">else</span> dtime=<span class="string">''</span>; <span class="keyword">end</span>
        printCurrentState([<span class="string">'Pzf '</span> num2str(Pzf) <span class="string">'FINALI         '</span> dtime])

    <span class="keyword">else</span>
        <span class="keyword">if</span>(DISPLAYtime) dtime=[<span class="string">' t('</span> num2str(toc) <span class="string">')'</span>]; <span class="keyword">else</span> dtime=<span class="string">''</span>; <span class="keyword">end</span>

        printCurrentState([<span class="string">'NOLAT_esti         '</span> dtime])
    <span class="keyword">end</span>

    <span class="comment">%%(3) #################### ACSTP FINAL ####################</span>

    [Bs Bt As At Class eigV fullBs{iter} fullBt{iter} fullAs{iter} fullAt{iter}]=CSTP(X,EEG.EpochClass,Xbarz,Weights,winElec,winTime,Pzf,Xnoise);

    <span class="comment">%%(3) #################### FINALIZATION ####################</span>
    <span class="comment">% for visualization after weights, latency correction and CSTP.</span>
    Zbarz{iter}=applyCSTP(Xbarz,Bs,Bt,As,At,Class);
    <span class="comment">% output will be usefull to find the best subspace-dimension</span>
    Output{2}{iter}=Zbarz{iter};
    Output{3}{iter}={Bs Bt As At};
    Output{4}{iter}=Weights;
    <span class="comment">%end</span>
    iter=iter+1;
</pre><pre class="codeinput"><span class="keyword">end</span>
<span class="comment">% find the best Pz for each class</span>
ACSTPstruct.EAoverlap=Output{1};<span class="comment">%standard arithmetic ensemble average</span>
<span class="keyword">for</span> indClass=1:size(Output{2}{1},3)
    [Pzind SNR]=best_Pz(Output{2},winElec,winTime,indClass);
    ACSTPstruct.Bs{indClass}=Output{3}{Pzind}{1}{indClass};
    ACSTPstruct.Bt{indClass}=Output{3}{Pzind}{2}{indClass};
    ACSTPstruct.As{indClass}=Output{3}{Pzind}{3}{indClass};
    ACSTPstruct.At{indClass}=Output{3}{Pzind}{4}{indClass};
    ACSTPstruct.EAcstp(:,:,indClass)=mean(Output{2}{Pzind}(:,:,indClass),3);
    ACSTPstruct.BestPz(indClass)=Pzfs(Pzind);
<span class="keyword">end</span>
ACSTPstruct.Latency=LatencyCorrection(:,Pzind);
ACSTPstruct.Weights=Output{4}{Pzind};
ACSTPstruct.Class=Class;
ACSTPstruct.fullBs=fullBs{Pzind};
ACSTPstruct.fullBt=fullBt{Pzind};
ACSTPstruct.fullAs=fullAs{Pzind};
ACSTPstruct.fullAt=fullAt{Pzind};
ACSTPstruct.PzSNR=SNR;

<span class="comment">% do the final filtering from initial data from the optimal</span>
<span class="comment">% SubspaceDimension</span>
TriggerCorrected=CorrectLatency(EEG.Trigger,ACSTPstruct.Latency);
X=epoch_p300(EEG.Channels,TriggerCorrected,Window); <span class="comment">%apply latency correction</span>
Xw=applyWeights(X,Output{4}{Pzind}); <span class="comment">%apply the weights</span>
Xhat=applyCSTP(Xw,ACSTPstruct.Bs,ACSTPstruct.Bt,ACSTPstruct.As,ACSTPstruct.At,EEG.EpochClass); <span class="comment">% apply the ACSTP</span>

<span class="keyword">if</span>(DISPLAYtime) dtime=[<span class="string">' t('</span> num2str(toc) <span class="string">')'</span>]; <span class="keyword">else</span> dtime=<span class="string">''</span>; <span class="keyword">end</span>
printCurrentState([<span class="string">'ACSTP has finished  '</span> dtime])

<span class="comment">% ACSTPstruct is a structure with</span>
<span class="comment">% EnsembleAverage: the ensemble average corrected with latencies, weighted</span>
<span class="comment">%                   and filtered + with the effect of overlapping</span>
<span class="comment">%                   correction</span>
<span class="comment">%     As Bs Bt At: such as Xhat(:,:,k)=As{indClass}*Bs{indClass}'*W(k)*X(:,:,k)*Bt{indClass}*At{indClass}'</span>
<span class="comment">%                   Each filter is a cell containing a matrix filter for</span>
<span class="comment">%                   each class</span>
<span class="comment">%           Class: The tag and the order in which the filter are sorted</span>
<span class="comment">%         Weights: [nb epochs x1] the weights of each epoch</span>
<span class="comment">%         Latency: [nb epochs x1] the corrected offset of each epoch</span>
</pre><h2>find best Pz and PLOT<a name="6"></a></h2><pre class="codeinput"><span class="keyword">if</span> DISPLAY
    disp(<span class="string">'WARNING : display not available, please see ACSTPshow.m'</span>)
<span class="keyword">end</span>


<span class="comment">% include all needed functions</span>
<span class="comment">% *** History: 5-June-2015</span>
<span class="comment">% *** Author: Louis KORCZOWSKI, GIPSA-Lab, 2015</span>
<span class="comment">% for the full commented versions please contact me :</span>
<span class="comment">% louis.korczowski [at] gmail.com</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%% NESTED %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
    <span class="keyword">function</span> [Bs Bt As At Class eigV fullBs fullBt fullAs fullAt]=CSTP(X,Y,P,W,winElec,winTime,Pzf,Xnoise)
</pre><pre class="codeinput">        <span class="keyword">if</span> nargin&lt;8
            Xnoise=X;

        <span class="keyword">end</span>
        <span class="keyword">if</span> nargin&lt;5 || isempty(winElec) || isempty(winTime)
            winElec=1:size(X,1);
            winTime=1:size(X,2);
        <span class="keyword">end</span>


        <span class="keyword">if</span> nargin&lt;4 || isempty(W);
            W=ones(1,size(X,3));
        <span class="keyword">end</span>


        <span class="keyword">if</span> nargin&lt;3 || isempty(P) <span class="comment">%check and verify the average P300</span>
            P=[];Bool=1; <span class="comment">%non overlapping method</span>
        <span class="keyword">else</span>
            Bool=0; <span class="comment">%use already computed mean P300</span>
            <span class="keyword">if</span> ~iscell(P) <span class="comment">%check if the ERP is with a cell structure</span>
                tmpP=P;
                nbClasses=size(P,3);
                clear <span class="string">P</span>
                <span class="keyword">for</span> z=1:nbClasses
                    P{z}=tmpP(:,:,z);<span class="comment">%one cell for each class</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="comment">% Algo Parameters</span>
        eigWhite1=1:size(X,1);
        eigWhite2=1:size(X,2);

        <span class="keyword">if</span> nargin&lt;2 || isempty(Y)
            Y=ones(size(X,3),1);
        <span class="keyword">end</span>



        Class=unique(Y);
        nbClasses=length(Class);
        Nbe=size(X,1);

        <span class="keyword">if</span> Bool==1
            <span class="keyword">for</span> z=1:nbClasses
                <span class="comment">%estimate the EAE if needed</span>
                P{z}=EnsembleAverage(X(:,:,Y==Class(z))); <span class="comment">%(0.10)</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">%%%%%%%%%%%%%%%% START COMPUTING CSPT %%%%%%%%%%%%%%%%%%%%%%%%</span>
        <span class="comment">%compute Sample covariance matrices for each sweep</span>
        <span class="keyword">for</span> k=1:size(Xnoise,3)
            <span class="comment">%             Cs_k(:,:,k)=Xnoise(:,:,k)*Xnoise(:,:,k)'/(size(Xnoise,2)-1); %scm</span>
            Cs_k(:,:,k)=cov(Xnoise(:,:,k)');
            <span class="comment">%             Ct_k(:,:,k)=Xnoise(:,:,k)'*Xnoise(:,:,k)/(size(Xnoise,1)-1); %scm</span>
            Ct_k(:,:,k)=cov(Xnoise(:,:,k));
        <span class="keyword">end</span>

        <span class="comment">%mean covariance matrices</span>
        Cs=mean(Cs_k,3); <span class="comment">%(0.15)</span>
        Ct=mean(Ct_k,3); <span class="comment">%(0.15)</span>

        <span class="comment">%%%%%%%%%%%%%%%%%%%%% BILINEAR WHITENING %%%%%%%%%%%%%%%%%%%%%%%%</span>
        [Ux Ws]=eig(Cs); <span class="comment">%(0.18)</span>
        [Vx Wt]=eig(Ct); <span class="comment">%(0.18)</span>

        [Ws,ind] = sort(diag(Ws),<span class="string">'descend'</span>);
        sumWs=cumsum(Ws);
        indWhite1tmp=find(sumWs&gt;max(sumWs)*(1-1e-12),1);
        <span class="comment">% suppress only the smallest spatial eigenvectors to keep (1-1e-12)% of the</span>
        <span class="comment">% power of the signal</span>

        <span class="keyword">if</span> max(eigWhite1)&gt;indWhite1tmp
            eigWhite1=1:indWhite1tmp;
        <span class="keyword">end</span>
        <span class="keyword">if</span> any(Ws(eigWhite1)&lt;=0); disp(<span class="string">'Warning negative SPATIAL eigenvalue(s)'</span>); <span class="keyword">end</span>

        Ux = Ux(:,ind);<span class="comment">%sort spatial eigenvector</span>
        Ux = Ux(:,eigWhite1);<span class="comment">%whitening reduction</span>
        [Wt,ind] = sort(diag(Wt),<span class="string">'descend'</span>);
        sumWt=cumsum(Wt);
        indWhite2tmp=find(sumWt&gt;max(sumWt)*(1-1e-12),1);
        <span class="comment">% suppress only the smallest temporal eigenvectors to keep (1-1e-12)% of the</span>
        <span class="comment">% power of the signal</span>

        <span class="keyword">if</span> max(eigWhite2)&gt;indWhite2tmp
            eigWhite2=1:indWhite2tmp;
        <span class="keyword">end</span>
        <span class="keyword">if</span> any(Wt(eigWhite2)&lt;=0); disp(<span class="string">'Warning negative TEMPORAL eigenvalue(s)'</span>); <span class="keyword">end</span>

        Vx = Vx(:,ind); <span class="comment">%sort temporal eigenvector</span>
        Vx = Vx(:,eigWhite2);<span class="comment">%whitening reduction</span>

        Fsp = (sqrt(pinv(diag(Ws(eigWhite1)))) * Ux')'; <span class="comment">%(0.19)</span>
        Ft =(sqrt(pinv(diag(Wt(eigWhite2)))) * Vx')'; <span class="comment">%(0.19)</span>
        Gs =Ux*sqrt((diag(Ws(eigWhite1)))) ; <span class="comment">%(0.20)</span>
        Gt =Vx*sqrt((diag(Wt(eigWhite2)))) ; <span class="comment">%(0.20)</span>
        <span class="comment">%%%%%%%%%%%%%% WHITENING MATRICES COMPUTED %%%%%%%%%%%%%%%</span>
</pre><h2>%%%%%%%%%%%% COMPUTE CSTP FILTERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<a name="8"></a></h2><pre class="codeinput">        <span class="keyword">for</span> z=1:length(P) <span class="comment">%for each class</span>
            Z{z}=Fsp'*P{z}*Ft; <span class="comment">%EAE whitening (0.22)</span>
            [Uz{z},Wz{z},Vz{z}]=svd((Z{z})); <span class="comment">% (0.23)</span>

            <span class="comment">%[Uz{z},Wz{z},Vz{z}]=svds((Z{z}),min(indWhite1tmp,indWhite2tmp)); % (0.23)</span>

            <span class="comment">%figure;plot(diag(Wz{z}))</span>

            <span class="keyword">if</span> exist(<span class="string">'Pzf'</span>) <span class="comment">%if Pzf has be given by the user (adviced)</span>
                eigV=1:Pzf;
            <span class="keyword">else</span>
                <span class="comment">%%%%%%%%%%%%%% FIND OPTIMAL Pz (optional) %%%%%%%%%%%%%%</span>
                <span class="comment">%eigV=find(diag(Wz{z}.^2)&gt;SNR); (0.27)</span>
                Fdenum=norm(Z{z},<span class="string">'fro'</span>).^2;
                <span class="keyword">for</span> Pz=Nbe*0.75:Nbe-1

                    Uz_r{z}=Uz{z}(:,1:Pz);
                    Vz_r{z}=Vz{z}(:,1:Pz);
                    Zz=Uz_r{z}*Wz{z}(Pz,Pz)*Vz_r{z}';
                    Fnum=norm(Zz(winElec,winTime),<span class="string">'fro'</span>).^2;
                    indPz(Pz)=Fnum/Fdenum;

                <span class="keyword">end</span>
                [~, Pze]=max(indPz);
                eigV=1:Pze;
                <span class="comment">%%%%%%%%%%%%%% FIND OPTIMAL Pz END (optinal) %%%%%%%%%%%%%%</span>
            <span class="keyword">end</span>


            <span class="keyword">if</span> isempty(eigV) <span class="comment">%if no optimal Pz</span>
                eigV=1;
            <span class="keyword">end</span>
            <span class="keyword">if</span> max(eigV)&gt;size(Uz{z},1) | max(eigV)&gt;size(Vz{z},1)
                error(<span class="string">'Subspace dimension (Pz) too high, estimated covariance matrix is lower rank. Try reduce the SubspaceDim'</span>)
            <span class="keyword">end</span>
            Uz_r{z}=Uz{z}(:,eigV); <span class="comment">%subspace reduction</span>
            Vz_r{z}=Vz{z}(:,eigV); <span class="comment">%subspace reduction</span>


            <span class="comment">% Compute Bs, Bt, As and At with both whitening and subspace reduction</span>
            Bs{z}=Fsp*Uz_r{z};<span class="comment">%Bz (0.24)</span>
            Bt{z}=Ft*Vz_r{z};<span class="comment">%Dz (0.24)</span>
            As{z}=Gs* Uz_r{z}; <span class="comment">%Az (0.24)</span>
            At{z}=Gt* Vz_r{z}; <span class="comment">%Ez (0.24)</span>

            fullBs{z}=Fsp*Uz{z}; <span class="comment">%only for display purpose</span>
            fullBt{z}=Ft*Vz{z}; <span class="comment">%only for display purpose</span>
            fullAs{z}=Gs* Uz{z}; <span class="comment">%only for display purpose</span>
            fullAt{z}=Gt* Vz{z}; <span class="comment">%only for display purpose</span>
        <span class="keyword">end</span>
        <span class="comment">%topoplot_components(fullAt, fullAs,[0 1],250,9,5,'d:\tmp\') %needed to</span>
        <span class="comment">%check the components of the filter.</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>

    <span class="keyword">function</span> Xw=applyCSTP(X,Bs,Bt,As,At,Y)
        <span class="keyword">if</span> nargin&lt;6
            Y=ones(1,size(X,3));
        <span class="keyword">end</span>
        Classes=unique(Y);
        <span class="keyword">for</span> k=1:size(X,3)
            c=find(Y(k)==Classes);
            Xw(:,:,k)=As{c}*Bs{c}'*X(:,:,k)*Bt{c}*At{c}';
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">function</span> [P Class]=EnsembleAverage(E,Y,Flash,Window,W)
        <span class="keyword">if</span> nargin&gt;2
            <span class="keyword">if</span> isempty(Y)
                Y=ones(length(find(Flash)),1);
            <span class="keyword">end</span>
            <span class="keyword">if</span> isempty(Flash) || isempty(Window) || length(find(Flash))~=length(Y) || nargin&lt;4
                error(<span class="string">'Invalid Inputs in EnsembleAverage please check Flash or Window'</span>)
            <span class="keyword">end</span>
            Xep=epoch_p300(E,Flash,Window);

        <span class="keyword">end</span>

        <span class="keyword">if</span> nargin&lt;3
            Window=size(E,2);
            Xep=E;
            <span class="keyword">if</span> nargin&lt;2
                Y=ones(1,size(Xep,3));
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">if</span> nargin&gt;4
            Xep=applyWeights(Xep,W);
        <span class="keyword">end</span>




        Class=unique(Y);
        P=zeros(size(E,1),Window,length(Class));
        <span class="keyword">for</span> z=1:length(Class)
            c=find(Y==Class(z));
            P(:,:,z)=mean(Xep(:,:,c),3);
        <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">function</span> [Emean Class]=meanOverlap(E,Flash,Window,TAG,Weights,doregression)
        <span class="keyword">if</span> nargin&lt;6 || isempty(doregression)
            doregression=1;
        <span class="keyword">end</span>
        <span class="keyword">if</span> nargin&lt;5 || isempty(Weights)
            Weights=ones(length(find(Flash)),1);
        <span class="keyword">end</span>

        <span class="keyword">if</span> nargin&lt;4 || isempty(TAG)
            TAG=ones(length(find(Flash)),1);
        <span class="keyword">end</span>
        N=size(E,2);
        Class=unique(TAG);

        indFlash=find(Flash);<span class="comment">%all Flashes (target and non-target)</span>
        <span class="keyword">if</span> (Window*length(Class))&gt;1024, warning([<span class="string">'number of classes ('</span> num2str(length(Class)) <span class="string">') or length epochs ('</span> num2str(Window) <span class="string">' samples) are too big, cancelled regression.'</span>]);doregression=0;<span class="keyword">end</span>

        <span class="comment">%check if the trials are overlapping</span>
        <span class="keyword">if</span> any(indFlash(1:end-1)+Window&gt;indFlash(2:end)) &amp; doregression  <span class="comment">%LS regression</span>
            <span class="comment">%build the weighted toeplitz matrix</span>
            Toep=[];
            <span class="keyword">for</span> iz=1:length(Class)
                FlashZ=zeros(N,1);
                indFZ=indFlash(TAG==Class(iz));
                FlashZ(indFZ)=Weights(TAG==Class(iz)); <span class="comment">%include Weights in the Toeplitz matrix</span>
                Toep=[Toep;toeplitz(zeros(1,Window),FlashZ)];<span class="comment">% Toeplitz matrix for each class</span>
                WeigthsCalib(iz)=(sum(Weights(TAG==Class(iz)).^2)/sum(Weights(TAG==Class(iz))));
            <span class="keyword">end</span>

            Emean=E*Toep'*pinv(Toep*Toep');

            Emean=reshape(Emean,[size(E,1),Window,length(Class)]);
            <span class="keyword">for</span> iz=1:length(Class)
                Emean(:,:,iz)=Emean(:,:,iz)*WeigthsCalib(iz); <span class="comment">%(0.19) Weight correction</span>
            <span class="keyword">end</span>
        <span class="keyword">else</span> <span class="comment">%arithmetic ensemble average</span>
            <span class="comment">%     disp('AEA')</span>
            indFlash=find(Flash);
            <span class="keyword">for</span> idf=1:length(indFlash)
                epoch(:,:,idf)=E(:,indFlash(idf):indFlash(idf)+Window-1)*Weights(idf);
            <span class="keyword">end</span>
            <span class="keyword">for</span> iz=1:length(Class)
                Emean(:,:,iz)=mean(epoch(:,:,TAG==Class(iz)),3); <span class="comment">%(0.19) 1/sum(Weights(TAG==Class(iz)))*</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">function</span> [X isBad] = epoch_p300(Signal,Target,window,offset,Artefacts)
        <span class="keyword">if</span> (nargin&lt;5 || isempty(Artefacts))
            Artefacts=zeros(1,length(Target));
        <span class="keyword">end</span>
        <span class="keyword">if</span> (nargin &lt; 4 || isempty(offset))
            offset = 0;
        <span class="keyword">end</span>
        ixTarget = find(Target);
        <span class="keyword">while</span> (ixTarget(end)+window-1)&gt;size(Signal,2)
            ixTarget(end) = [];
        <span class="keyword">end</span>
        NTarget = length(ixTarget);
        X = zeros(size(Signal,1),window,NTarget);
        isBad=zeros(1,NTarget);
        <span class="keyword">for</span> i=1:NTarget
            X(:,:,i) = Signal(:,ixTarget(i)+offset:ixTarget(i)+window-1+offset);
            isBad(i)= length(find(Artefacts(ixTarget(i)+offset:ixTarget(i)+window-1+offset)&gt;0));
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">function</span> [W,Xhatk]=WeightsEstimation(X,Y,Bs,Bt,As,At)

        W=ones(1,size(X,3));
        <span class="keyword">if</span> nargin&lt;2
            Y=ones(size(X,3),1);
        <span class="keyword">end</span>
        Classes=unique(Y); <span class="comment">% find all the classes</span>

        <span class="keyword">if</span> nargin&lt;3 <span class="comment">%%no CSTP weights (initialization)</span>
            <span class="keyword">for</span> k=1:size(X,3) <span class="comment">% for each epoch</span>
                W(k)=1/norm(X(:,:,k),<span class="string">'fro'</span>); <span class="comment">%compute the initilized weights</span>
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            Xhatk=zeros(size(X));
            <span class="keyword">for</span> k=1:size(X,3) <span class="comment">% for each epoch</span>
                <span class="comment">%                 Xk=X(:,:,k);</span>
                c=(Y(k)==Classes); <span class="comment">% class of the current epoch</span>
                Xhatk(:,:,k)=As{c}*Bs{c}'*X(:,:,k)*Bt{c}*At{c}'; <span class="comment">% signal estimation</span>
                W(k)=norm(Xhatk(:,:,k) ,<span class="string">'fro'</span>)/norm( X(:,:,k)-Xhatk(:,:,k),<span class="string">'fro'</span>); <span class="comment">% SNR estimation</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span>
        <span class="comment">% Weights normalization</span>
        <span class="keyword">for</span> z=1:length(Classes) <span class="comment">% for each class</span>
            Wz=W(Y==Classes(z));
            W(Y==Classes(z))=length(Wz)*Wz/sum(Wz); <span class="comment">% normalize each class weights</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">function</span> FlashCorrected=CorrectLatency(Flash,Latencies,RND)
        <span class="keyword">if</span> nargin&lt;3
            RND=1:length(find(Flash)); <span class="comment">%no random seed</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> size(Flash,1) == 1, Flash = Flash'; <span class="keyword">end</span>;
        FlashCorrected=zeros(size(Flash));
        indF=find(Flash);
        <span class="keyword">if</span> length(indF)~=Latencies
            indF(RND)=indF(RND)+Latencies;
            indFcorrected=indF;
        <span class="keyword">else</span>
            indFcorrected=indF+Latencies;
        <span class="keyword">end</span>
        FlashCorrected(indFcorrected)=1;
    <span class="keyword">end</span>

    <span class="keyword">function</span> Conv=ConvergenceLatencies(Lat1,Lat2)
        Conv=mean(abs(Lat1-Lat2));
    <span class="keyword">end</span>

    <span class="keyword">function</span> [Latency Crit_TraceN]=LatencyEstimation(Xall,X,Y,W,Bs,Bt,As,At,winElec,winTime)

        WindowSize=size(X,2);
        SizeMax=size(Xall,2);
        finalInd=SizeMax-WindowSize;
        delay0=floor(finalInd/2)+1;
        <span class="keyword">if</span> nargin&lt;3
            Y=ones(size(X,3),1);
        <span class="keyword">end</span>
        <span class="keyword">if</span> nargin&lt;4
            W=ones(size(Y));
        <span class="keyword">end</span>
        Xweighted=applyWeights(X,W);
        Xallw=applyWeights(Xall,W);
        Classes=unique(Y);

        <span class="keyword">if</span> nargin&lt;5 || isempty(Bs)
            <span class="keyword">for</span> i=1:length(Classes)
                Bs{i}=eye(size(X,1));
                Bt{i}=eye(size(X,2));
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> nargin&lt;7 || isempty(As)
            <span class="keyword">for</span> i=1:length(Classes)

                As{i}=eye(size(X,1));
                At{i}=eye(size(X,1));
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> nargin&lt;9
            winElec=1:size(X,1);
        <span class="keyword">end</span>
        <span class="keyword">if</span> nargin&lt;10
            winTime=1:size(X,2);
        <span class="keyword">end</span>

        <span class="keyword">for</span> k=1:size(Xall,3)

            z=find(Classes==Y(k));
            Xother=Xweighted(:,:,[1:k-1 k+1:end]);
            Tag=Y([1:k-1 k+1:end]);
            Xother=Xother(:,:,Tag==Classes(z));
            Pother=mean(Xother,3); <span class="comment">%P300 estimation</span>
            Ybar=Bs{z}'*Pother*Bt{z};
            <span class="comment">%Xbar=As{z}*Ybar*At{z}';</span>

            <span class="comment">%%%%%%% WARNING : this part need to be optimize %%%%%%%%%%%%%%%%%%%%%%%</span>
            <span class="keyword">for</span> lat=1:finalInd+1
                Xtmp=Xallw(:,lat:lat+WindowSize-1,k);
                Xwk=zeros(size(Xtmp));
                Xwk(winElec,winTime)=Xtmp(winElec,winTime);
                Yk=Bs{z}'*Xwk*Bt{z};
                <span class="comment">%Xk=As{z}*Yk*At{z}';</span>

                Criterion_Trace(k,lat)=trace(Ybar*Yk');
            <span class="keyword">end</span>
            <span class="comment">%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

            Crit_TraceN(k,:)=Criterion_Trace(k,:)-min(Criterion_Trace(k,:));<span class="comment">%normalize criteria</span>
            [Pik Peaks]=findpeaks(Crit_TraceN(k,:)); <span class="comment">%criteria</span>

            <span class="keyword">if</span> isempty(Peaks)
                Peaks=delay0;
            <span class="keyword">else</span>
                indP=find(Pik&gt;max(Pik)*0.66); <span class="comment">%accept only peak of 66% of max (heuristic criteria)</span>
                Peaks=Peaks(indP);
            <span class="keyword">end</span>


            [trash IndM]=min(abs(Peaks-delay0)); <span class="comment">%choose closest peak from allowed ones</span>
            Latency(k)=Peaks(IndM)-delay0;

        <span class="keyword">end</span>

        Latency=Latency';

    <span class="keyword">end</span>

    <span class="keyword">function</span> [Pzind SNR]=best_Pz(Zbarz,Electrodes,Window,indClass)
        <span class="comment">% it is important that the Pz are sorted in descend order</span>
        <span class="keyword">if</span> nargin&lt;4
            indClass=size(Zbarz{1},3); <span class="comment">%take the "target" class that should be the last</span>
        <span class="keyword">end</span>
        <span class="keyword">for</span> i=1:length(Zbarz)
            noise=Zbarz{i}(:,:,indClass);
            signal=noise(Electrodes,Window);
            SNR(i)=norm(signal,<span class="string">'fro'</span>)/norm(noise,<span class="string">'fro'</span>);
        <span class="keyword">end</span>
         SNR = smooth(SNR,3);<span class="comment">%EXPERIMENTAL : smooth SNR (moving average 3 points)</span>
         SNR=SNR-min(SNR);
        <span class="keyword">if</span> length(Zbarz)&gt;3 &amp; length(unique(SNR))&gt;1
            [maxs INDtmp]=findpeaks(SNR);

            plot(SNR);hold <span class="string">on</span>;plot(INDtmp,maxs,<span class="string">'ro'</span>)

        <span class="keyword">else</span>
            INDtmp=[];
        <span class="keyword">end</span>
        [tmpPz Pzind]=max(SNR(2:end-1));Pzind=Pzind+1;<span class="comment">%EXPERIMENTAL : remove the first and last for the computation of the maximum</span>

        <span class="keyword">if</span> ~isempty(INDtmp)
            IND=INDtmp(maxs&gt;(tmpPz*0.66));
            <span class="keyword">if</span> ~isempty(IND)
                Pzind=IND(1);<span class="comment">%take the greatest valid Pz</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">%check that you don't take the maximum or minimum Pz</span>
        <span class="keyword">if</span> length(Zbarz)&gt;=3
            <span class="keyword">if</span> Pzind==length(Zbarz),Pzind=Pzind-1;<span class="keyword">end</span>
            <span class="keyword">if</span> Pzind==1,Pzind=Pzind+1;<span class="keyword">end</span>
        <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">function</span> printCurrentState(INFO,previousLine)
        <span class="keyword">if</span> nargin&lt;2
            previousLine=true;
        <span class="keyword">end</span>
        str = [sprintf(INFO)];
        <span class="keyword">if</span> previousLine
            str = [sprintf(char(repmat(double(<span class="string">'\b'</span>),1,length(str)+1))) str];
        <span class="keyword">end</span>
        disp(str);
    <span class="keyword">end</span>

    <span class="keyword">function</span> Xw=applyWeights(X,W)

        <span class="keyword">for</span> k=1:length(W)
            Xw(:,:,k)=X(:,:,k)*W(k);
        <span class="keyword">end</span>

    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
function [Xhat ACSTPstruct]=ACSTP(EEG,ACSTPoptions)
%%%% Adaptive Common Spatio-Temporal Pattern 
% [Xhat ACSTPstruct]=ACSTP(EEG,ACSTPoptions)
%
% Compute the Adaptive Common Spatio-Temporal Pattern Filter (ACSTP) from the
% continuous recording EEG.
%
% The estimated ERP epochs Xhat are returned such as :
% for X the EEG epochs with corrected latencies and with weights W, the ACSTP filter, does:
% Xhat(:,:,k)=As*Bs'*W(k)*X(:,:,k)*Bt*At';
%
% With the output ACSTPstruct, you can manually apply the filter on the EEG
% such as :
% TriggerCorrected=CorrectLatency(EEG.Trigger,ACSTPstruct.Latency); % apply latency correction
% X=epoch_p300(EEG.Channels,TriggerCorrected,ACSTPstruct.Epoch_size); % extract the epochs
% Xw=applyWeights(X,ACSTPstruct.Weights); %apply the weights
% Xhat=applyCSTP(Xw,ACSTPstruct.Bs,ACSTPstruct.Bt,ACSTPstruct.As,ACSTPstruct.At,EEG.EpochClass); %apply the ACSTP
%
%
%%%% INPUTS :
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% EEG is a structure with
%              Fs: scalar (sample rate in Hz)
%         Trigger: [nb samples x1 ] Trigger channel of '0' with '1' at the start
%                   of each sweep. There are [nb epochs] '1'.
%      EpochClass: [nb epochs x1] class of the sweeps (0 for Non-TARGET, 1
%                   for TARGET).
%        Channels: [nb samples x nb channels] preprocessed EEG recordings
%   NoiseTrigger*: the equivalent of Trigger but for the sweep of the noise.
%                   By default, it takes the same.
% ElectrodesName*: {1 x nb channels} the names of the electrodes (usefull
%                  only in case of plot, i.e. ACSTPoptions.DISPLAY=true)
%
% ACSTPoptions is a structure with
%      Epoch_size: scalar, the length of the epoch window (in samples)
% LatencyCorr_max: scalar, the maximum of samples for the latency
%                   correction. Set 0 to disable the Latency correction.
% Mask_Electrodes: vector of the selectionned electrodes. Usefull for the
%                  automatic subspace selection (BestPz) and latency
%                  correction (Latency).
%       Mask_Time: vector of the selectionned sample. Usefull for the
%                  automatic subspace selection (BestPz) and latency
%                  correction (Latency).
% MaxIterLatency*: scalar, the maximum iteration allowed to compute the
%                   latency correction. Default: 10.
%    SubspaceDim*: vector, containing all the subspace dimension (<nb electrodes)
%                  to test in descent order.
%                   By default, it is equal to (nb_channels:-1:(nb_channels/2))
%computeClassLat*: vector, containing all the class tag in which you want
%                   to compute the latency correction. By default, it
%                   computes it for all classes but it could be long (for
%                   instance you can skip the non-target).
%        Weights*: Default: true.
%                  option1(given) [nb epochs x1] vector, containing the weights for each
%                   epoch if it is computed from an external function.
%                  option2 (true/false) boolean. If true (default) the ACSTP compute the
%                   weight for each epoch. If false, the weights are
%                   desactivated (i.e. set to 1).
%        overlap*: Default: true (1). If set to 0, it will consider that
%                   the epochs are not overlapping and it will compute the standard
%                   ensemble average. If the window of your epochs is big (>1024 samples), it could be
%                   also interesting to disable this function to speed up the process.
%        DISPLAY*: Boolean, should the comparative result between the arithmetic ensemble
%                   average and the ACSTP should be display at the end. Default: false.
%
%   *optional
%
%%%% OUTPUT :
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% Xhat with corrected latencies, weighted and filtered
% ACSTPstruct is a structure with
%              EA: the ensemble average before ACSTP
%          EAcstp: the ensemble average corrected with latencies, weighted
%                   and filtered + with the effect of overlapping
%                   correction
%     As Bs Bt At: such as Xhat(:,:,k)=As{indClass}*Bs{indClass}'*W(k)*X(:,:,k)*Bt{indClass}*At{indClass}'
%                   Each filter is a cell containing a matrix filter for
%                   each class
%           Class: The tag and the order in which the filter are sorted
%          BestPz: Orders of the best subspace for the ACSTP for the given
%                  Class
%         Weights: [nb epochs x1] the weights of each epoch
%         Latency: [nb epochs x1] the corrected offset of each epoch
%      Epoch_size: scalar, the length of the epoch window (in samples)
%
%
% *** History: 11-Nov-2015
% *** Author: Louis KORCZOWSKI, GIPSA-Lab, 2015
% *** Related work: M. CONGEDO, L. KORCZOWSKI, A. DELORME, F. LOPES DA SILVA "Spatio-Temporal Common Pattern a Reference Companion Method for ERP Analysis" (submitted)
%
% see also : ACSTPshow, script_ACSTP_test

Xhat=[];
ACSTPstruct=struct;
EEG.Channels=double(EEG.Channels);
if ~isfield(ACSTPoptions,'DISPLAY')
    DISPLAY=0; %put '1' to plot the results at the end of the computation or '0' to not.
else
    DISPLAY=ACSTPoptions.DISPLAY;
end
if ~isfield(ACSTPoptions,'overlap')
    ACSTPoptions.overlap=1;
end
DISPLAYtime=0;%set on for debug (optimization)
if( DISPLAYtime) tic; end
%%%%%%%%%%%%%%%%%% INPUT EXTRACTIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%check if the row are the electrodes and the columns are the samples
if size(EEG.Channels,1)>size(EEG.Channels,2),EEG.Channels=EEG.Channels';end


if isfield(EEG,'NoiseTrigger'),NoiseTrigger=EEG.NoiseTrigger;else NoiseTrigger=[];end

if (size(EEG.EpochClass,1)==1),EEG.EpochClass=EEG.EpochClass';end %transpose vector if necessary
if (size(EEG.Trigger,1)==1),EEG.Trigger=EEG.Trigger';end %transpose vector if necessary


%Check if the EEG INPUTS are correct
if size(EEG.Channels,2)<size(EEG.Channels,1)
    error(['EEG INPUT ERROR1: the temporal dimension of EEG.Channels is smaller than the spatial dimension.' ...
        ' Please check that EEG.Channels'' size is [nb samples x nb channels].' ]);
end

% check EEG.Trigger Channel
if ~(size(EEG.Channels,2)==length(EEG.Trigger))
    warning('ACSTP WARNING2: Size of EEG.Trigger not equals to nb samples of EEG.Channels')
    if length(EEG.Trigger)==length(EEG.EpochClass)
        %we assume that EEG.Trigger gives the position of the EEG.EpochClass instead of
        %being a trigger channel at the sample rate EEG.Fs
        tmp=zeros(size(EEG.Channels,2),1);
        tmp(EEG.Trigger)=1;
        EEG.Trigger=tmp;
        clear tmp
        warning('EEG.Trigger has been assumed to be the EEG.EpochClass locations instead of a trigger channel at the sample rate EEG.Fs')
    else
        error('ACSTP ERROR3: EEG INPUT ERROR.')
        
    end
end

% check NoiseTrigger Channel (if exist)
if ~isempty(NoiseTrigger)
    if ~(size(EEG.Channels,2)==length(NoiseTrigger))
        warning('ACSTP WARNING2b: Size of EEG.NoiseTrigger not equals to nb samples of EEG.Channels')
        %we assume that NoiseTrigger gives the position of the EEG.EpochClass instead of
        %being a trigger channel at the sample rate EEG.Fs
        tmp=zeros(size(EEG.Channels,2),1);
        tmp(NoiseTrigger)=1;
        NoiseTrigger=tmp;
        clear tmp
        warning('EEG.NoiseTrigger has been assumed to be the EEG.EpochClass locations instead of a trigger channel at the sample rate EEG.Fs')
    end
end


%%%%%%%%%%%%%%%%%% CSTP PARAMETERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


if nargin<2
    Window=1*EEG.Fs; %(11) the sweeps window will be 1s
    Delays=4; %(12) +/- nb shifted samples allowed for the jitter correction
    winElec=[7,9,10,11,12,13,14,15,16]; %(13)* electrodes used for latency calculation and Pz selection
    % exemple: Cz(7),P7(9),P3(10),Pz(11),P4(12),P8(13),O1(14),Oz(15),O2(16)
    winTime=[floor((0.05)*128):ceil((0.550)*128)]; %(14)* time window (in sample) used for latency calculation and Pz selection
    % exemple: 50ms to 550ms
else
    Window=ACSTPoptions.Epoch_size;
    if isfield(ACSTPoptions,'LatencyCorr_max')
        Delays=ACSTPoptions.LatencyCorr_max;
        if isempty(Delays)
            Delays=0;
        end
    else
        Delays=0;
    end
    if ~isfield(ACSTPoptions,'Mask_Electrodes')
        winElec=1:size(EEG.Channels,1);%put all electrodes
    elseif isempty(ACSTPoptions.Mask_Electrodes)
        winElec=1:size(EEG.Channels,1);%put all electrodes
    else
        winElec=ACSTPoptions.Mask_Electrodes;
    end
    
    if ~isfield(ACSTPoptions,'Mask_Time')
        winElec=1:Window;%put all samples
    elseif isempty(ACSTPoptions.Mask_Time)
        winElec=1:Window;%put all samples
        
    else
        winTime=ACSTPoptions.Mask_Time;
    end
end
%Check if the ACSTP INPUTS are correct
if any(find(EEG.Trigger)+Window-1>size(EEG.Channels,2))
    error('ACSTP ERROR4: ACSTP INPUT ERROR. The size of the epochs choosen in ACSTPoptions.Epoch_size is too big for the last event in EEG.Trigger.');
end
if ~isempty(NoiseTrigger)
    if any(find(NoiseTrigger)+Window>size(EEG.Channels,2))
        error('ACSTP ERROR4b: ACSTP INPUT ERROR. The size of the epochs choosen in ACSTPoptions.Epoch_size is too big for the last event in EEG.NoiseTrigger.');
    end
end
if any(find(EEG.Trigger)+Window+Delays-1>size(EEG.Channels,2))
    error('ACSTP ERROR5: ACSTP INPUT ERROR. The delays choosen in ACSTPoptions.LatencyCorr_max is too big for the last event in EEG.Trigger.');
    
end
if any(find(EEG.Trigger)-Delays<1)
    error('ACSTP ERROR6: ACSTP INPUT ERROR. The delays choosen in ACSTPoptions.LatencyCorr_max is too big for the first event in EEG.Trigger.');
    
end
if any(max(winElec)>size(EEG.Channels,1))
    error('ACSTP ERROR7: ACSTP INPUT ERROR. ACSTPoptions.Mask_Electrodes incorrect');
    
end
if any(max(winTime)>Window)
    error('ACSTP ERROR8: ACSTP INPUT ERROR. ACSTPoptions.Mask_Time incorrect');
    
end
%%%%%%% ADDITIONNALS STRUCTURES FOR ACSTP (no user input needed)%%%%%%%%%%%
WindowB=Window+2*Delays;
offset=-Delays;
[Xall]=epoch_p300(EEG.Channels,EEG.Trigger,WindowB,offset); %prepare epoch for full window+latency
if ~isfield(ACSTPoptions,'MaxIterLatency')
    maxIter_Latcor=10;
else
    maxIter_Latcor=ACSTPoptions.MaxIterLatency
end
if ~isfield(ACSTPoptions,'SubspaceDim')
    Pzfs=[size(Xall,1):-1:size(Xall,1)/2];%choose the screening of the Pz
else
    if isempty(ACSTPoptions.SubspaceDim)
        Pzfs=[size(Xall,1):-1:size(Xall,1)/2];%choose the screening of the Pz
    elseif max(ACSTPoptions.SubspaceDim)>size(EEG.Channels,1)
        error('ACSTP ERROR9: ACSTP INPUT ERROR. The subspace dimension(s) choosen in ACSTPoptions.SubspaceDim is/are greater than the number of electrodes.');
    elseif min(ACSTPoptions.SubspaceDim)<1
        error('ACSTP ERROR9: ACSTP INPUT ERROR. The subspace dimension(s) choosen in ACSTPoptions.SubspaceDim is/are smaller than 1.');
    else
        Pzfs=ACSTPoptions.SubspaceDim;
    end
end

%{
%the constant offset has been desactivated. If you'll like to add an
offset, please consider modifying EEG.Trigger as well as Epoch_size and Mask_Time
accordingly in ACSTPoptions.

if ~isfield(ACSTPoptions,'EpochsOffset')
    EpochsOffset=0;%offset has been set to zero
else
    EpochsOffset=ACSTPoptions.EpochsOffset;
    disp(['ACSTP INFO: The epochs will be with an offset of: ' num2str(EpochsOffset) ' samples.']);
    if (find(EEG.Trigger,1)-Delays+EpochsOffset<1)
        disp('ACSTP ERROR9: ACSTP INPUT ERROR. ACSTPoptions.EpochsOffset is too big for the first event in EEG.Trigger.');
    end
end
%}

% NOT GOOD what if computeClassLat is empty ????
if Delays>0
    if ~isfield(ACSTPoptions,'computeClassLat')
        ClassLat=unique(EEG.EpochClass);%all the classes
        disp(['ACSTP INFO: Latencies will be computed for class(es): ' num2str(ClassLat') '.']);
        disp('ACSTP INFO: Please consider only classes that need Latency correction to speed up the procedure.');
        disp( 'ACSTP INFO: See setting ACSTPoptions.computeClassLat');
        
    elseif isfield(ACSTPoptions,'computeClassLat')
        ClassLat=ACSTPoptions.computeClassLat;
        disp(['ACSTP INFO: Latencies will be computed only for class(es): ' num2str(ClassLat)]);
        
    end
end

% CHECK the Weights' estimation (true/false/given).
if ~isfield(ACSTPoptions,'Weights') % true (default)
    ComputeWeights=1; %ACSTP will estimate the Weights
    disp(['ACSTP INFO: Weights will be computed: ' num2str(ComputeWeights) ' (1=true/0=false)']);
else
    if(length(ACSTPoptions.Weights)==length(EEG.EpochClass)) %given
        ComputeWeights=0; %ACSTP will NOT estimate the Weights
        Weights=ACSTPoptions.Weights;
        warning(['ACSTP WARNING10: ACSTP INPUT WARNING. ACSTPoptions.Weights has been given and won''t be computed.'...
            ' Please check carefully your weights to avoid a scaling issue in output of the CSTP.']);
    elseif(length(ACSTPoptions.Weights)==1) %set true/false
        ComputeWeights=ACSTPoptions.Weights;%ACSTP does(true)/doesn't(false) estimate the Weights
        disp(['ACSTP INFO: Weights will be computed: ' num2str(ComputeWeights) ' (1=true/0=false)']);
    else %wrong size
        error('ACSTP ERROR11: ACSTP INPUT ERROR. ACSTPoptions.Weights size incorrect');
    end
    
end
if (~exist('Weights','var') && ~ComputeWeights) %if Weights estimation false
    Weights=ones(length(EEG.EpochClass),1);
end
%% ACSTP loop Algorithm

disp(['ACSTP INFO: Latency estimation: ' num2str(~(Delays==0)) ' (1=activated/0=disabled)']);

% Heuristic criterion for the Latency convergence:
CriteriaConvLatencies=1/length(find(EEG.EpochClass))*Delays; %nb latencies correction allowed for convergence.


[ACSTPstruct.EA]=EnsembleAverage(EEG.Channels,EEG.EpochClass,EEG.Trigger,Window);

%EEG.EpochClass=ones(size(EEG.EpochClass));
[Xbarz Class]=meanOverlap(EEG.Channels,EEG.Trigger,Window,EEG.EpochClass,[],ACSTPoptions.overlap);%estimate the arithmetic mean (0.10)
Output{1}=Xbarz; %save the AEA for future visualization
if(DISPLAYtime) dtime=[' t(' num2str(toc) ')']; else dtime=''; end
disp((['COMPUTE ACSTP... STATE20CHAR         ' dtime]))
printCurrentState(['START               ' dtime])
iter=1;%for each iteration, a Pz
for Pzf=Pzfs;
    %%
    
    
    %%(A.1) #################### DATA PREPARATION ####################
    X=epoch_p300(EEG.Channels,EEG.Trigger,Window); %get epochs
    
    if ~isempty(NoiseTrigger)
        Xnoise=epoch_p300(EEG.Channels,NoiseTrigger,Window);
    else
        Xnoise=X;
    end
    
    %if needed, we can estimate the noise covariance from differents epochs
    %(e.g. resting state or randomly selected epochs)
    
    
    %%(A.2) #################### LATENCY INITIALIZATION ####################
    
    LatencyCorrection(:,iter)=zeros(length(EEG.EpochClass),1); %initialization latency at zero
    
    %%(A.3) #################### WEIGHTS INITIALIZATION ####################
    if (ComputeWeights)
        Weights=WeightsEstimation(X,EEG.EpochClass);
    end
    
    %%(A.4) #################### Xbarz INITIALIZATION ####################
    
    [Xbarz Class]=meanOverlap(EEG.Channels,EEG.Trigger,Window,EEG.EpochClass,Weights,ACSTPoptions.overlap);
    
    if(DISPLAYtime) dtime=[' t(' num2str(toc) ')']; else dtime=''; end
    %%(B) #################### ACSTP Initialization ####################
    printCurrentState(['Pzf ' num2str(Pzf) 'ACSTP          ' dtime])
    [Bs Bt As At Class eigV]=CSTP(X,EEG.EpochClass,Xbarz,Weights,winElec,winTime,Pzf,Xnoise);
    
    %%(3) #################### Filtered Ensemble Average Initialization ####################
    Zbarz{iter}=applyCSTP(Xbarz,Bs,Bt,As,At,Class);
    
    Output{2}{iter}=Zbarz{iter}; %save after CSTP (initialized)
    Output{3}{iter}={Bs Bt As At};%save CSTP (initialized)
    
    if(DISPLAYtime) dtime=[' t(' num2str(toc) ')']; else dtime=''; end
    printCurrentState(['Pzf ' num2str(Pzf) 'WEIGHT         ' dtime])
    
    %%(3) #################### WEIGHTS ESTIMATION ####################
    if (ComputeWeights)
        Weights=WeightsEstimation(X,EEG.EpochClass,Bs,Bt,As,At);
    end
    
    %%(4) #################### LATENCY CORRECTION LOOP ####################
    if Delays>0 %ONLY IF THE DELAYS NEED TO BE COMPUTED
        for indCl=1:length(ClassLat)
            class_for_lat=ClassLat(indCl);
            classLat_indices=(EEG.EpochClass==class_for_lat);%just compute latencies for class target
            tempoLatency=[];
            STOPlat=1;
            iterLat=1;
            if(DISPLAYtime) dtime=[' t(' num2str(toc) ')']; else dtime=''; end
            printCurrentState(['Pzf ' num2str(Pzf) 'LATEN' num2str(class_for_lat) '         ' dtime])
            
            LatencyCorrection(classLat_indices,iter)=zeros(size(LatencyCorrection(classLat_indices,iter))); %initialize latencies
            while STOPlat %converge criteria
                
                [tempoLatency Crit_Trace]=LatencyEstimation(Xall(:,:,classLat_indices),X(:,:,classLat_indices),EEG.EpochClass(classLat_indices),Weights(classLat_indices),Bs(end),Bt(end),As(end),Bt(end),winElec,winTime);
                
                Conv(iter,iterLat)=ConvergenceLatencies(tempoLatency,LatencyCorrection(classLat_indices,iter));
                if (iterLat>1 && Conv(iter,iterLat)<CriteriaConvLatencies) || iterLat>=maxIter_Latcor
                    STOPlat=0;
                end
                LatencyCorrection(classLat_indices,iter)=tempoLatency;
                TriggerCorrected=CorrectLatency(EEG.Trigger,LatencyCorrection(:,iter));
                X=epoch_p300(EEG.Channels,TriggerCorrected,Window);
                iterLat=iterLat+1;
                
            end
            
        end
        
        
        %%(4) #################### CORRECT LATENCIES ####################
        TriggerCorrected=CorrectLatency(EEG.Trigger,LatencyCorrection(:,iter));
        X=epoch_p300(EEG.Channels,TriggerCorrected,Window);
        
        [Xbarz Class]=meanOverlap(EEG.Channels,TriggerCorrected,Window,EEG.EpochClass,Weights,ACSTPoptions.overlap);
        
        % Xbarz is then the EAE averaged with weighted epochs and with
        % corrected lattencies
        
        if(DISPLAYtime) dtime=[' t(' num2str(toc) ')']; else dtime=''; end
        printCurrentState(['Pzf ' num2str(Pzf) 'FINALI         ' dtime])
        
    else
        if(DISPLAYtime) dtime=[' t(' num2str(toc) ')']; else dtime=''; end
        
        printCurrentState(['NOLAT_esti         ' dtime])
    end
    
    %%(3) #################### ACSTP FINAL ####################
    
    [Bs Bt As At Class eigV fullBs{iter} fullBt{iter} fullAs{iter} fullAt{iter}]=CSTP(X,EEG.EpochClass,Xbarz,Weights,winElec,winTime,Pzf,Xnoise);
    
    %%(3) #################### FINALIZATION ####################
    % for visualization after weights, latency correction and CSTP.
    Zbarz{iter}=applyCSTP(Xbarz,Bs,Bt,As,At,Class);
    % output will be usefull to find the best subspace-dimension
    Output{2}{iter}=Zbarz{iter};
    Output{3}{iter}={Bs Bt As At};
    Output{4}{iter}=Weights;
    %end
    iter=iter+1;
    
    
end
% find the best Pz for each class
ACSTPstruct.EAoverlap=Output{1};%standard arithmetic ensemble average
for indClass=1:size(Output{2}{1},3)
    [Pzind SNR]=best_Pz(Output{2},winElec,winTime,indClass);
    ACSTPstruct.Bs{indClass}=Output{3}{Pzind}{1}{indClass};
    ACSTPstruct.Bt{indClass}=Output{3}{Pzind}{2}{indClass};
    ACSTPstruct.As{indClass}=Output{3}{Pzind}{3}{indClass};
    ACSTPstruct.At{indClass}=Output{3}{Pzind}{4}{indClass};
    ACSTPstruct.EAcstp(:,:,indClass)=mean(Output{2}{Pzind}(:,:,indClass),3);
    ACSTPstruct.BestPz(indClass)=Pzfs(Pzind);
end
ACSTPstruct.Latency=LatencyCorrection(:,Pzind);
ACSTPstruct.Weights=Output{4}{Pzind};
ACSTPstruct.Class=Class;
ACSTPstruct.fullBs=fullBs{Pzind};
ACSTPstruct.fullBt=fullBt{Pzind};
ACSTPstruct.fullAs=fullAs{Pzind};
ACSTPstruct.fullAt=fullAt{Pzind};
ACSTPstruct.PzSNR=SNR;

% do the final filtering from initial data from the optimal
% SubspaceDimension
TriggerCorrected=CorrectLatency(EEG.Trigger,ACSTPstruct.Latency);
X=epoch_p300(EEG.Channels,TriggerCorrected,Window); %apply latency correction
Xw=applyWeights(X,Output{4}{Pzind}); %apply the weights
Xhat=applyCSTP(Xw,ACSTPstruct.Bs,ACSTPstruct.Bt,ACSTPstruct.As,ACSTPstruct.At,EEG.EpochClass); % apply the ACSTP

if(DISPLAYtime) dtime=[' t(' num2str(toc) ')']; else dtime=''; end
printCurrentState(['ACSTP has finished  ' dtime])

% ACSTPstruct is a structure with
% EnsembleAverage: the ensemble average corrected with latencies, weighted
%                   and filtered + with the effect of overlapping
%                   correction
%     As Bs Bt At: such as Xhat(:,:,k)=As{indClass}*Bs{indClass}'*W(k)*X(:,:,k)*Bt{indClass}*At{indClass}'
%                   Each filter is a cell containing a matrix filter for
%                   each class
%           Class: The tag and the order in which the filter are sorted
%         Weights: [nb epochs x1] the weights of each epoch
%         Latency: [nb epochs x1] the corrected offset of each epoch



%% find best Pz and PLOT
if DISPLAY
    disp('WARNING : display not available, please see ACSTPshow.m')
end


% include all needed functions
% *** History: 5-June-2015
% *** Author: Louis KORCZOWSKI, GIPSA-Lab, 2015
% for the full commented versions please contact me :
% louis.korczowski [at] gmail.com

%%%%%%%%%%%%%%%%%%%%%%%%%%% NESTED %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    function [Bs Bt As At Class eigV fullBs fullBt fullAs fullAt]=CSTP(X,Y,P,W,winElec,winTime,Pzf,Xnoise)
        if nargin<8
            Xnoise=X;
            
        end
        if nargin<5 || isempty(winElec) || isempty(winTime)
            winElec=1:size(X,1);
            winTime=1:size(X,2);
        end
        
        
        if nargin<4 || isempty(W);
            W=ones(1,size(X,3));
        end
        
        
        if nargin<3 || isempty(P) %check and verify the average P300
            P=[];Bool=1; %non overlapping method
        else
            Bool=0; %use already computed mean P300
            if ~iscell(P) %check if the ERP is with a cell structure
                tmpP=P;
                nbClasses=size(P,3);
                clear P
                for z=1:nbClasses
                    P{z}=tmpP(:,:,z);%one cell for each class
                end
            end
        end
        % Algo Parameters
        eigWhite1=1:size(X,1);
        eigWhite2=1:size(X,2);
        
        if nargin<2 || isempty(Y)
            Y=ones(size(X,3),1);
        end
        
        
        
        Class=unique(Y);
        nbClasses=length(Class);
        Nbe=size(X,1);
        
        if Bool==1
            for z=1:nbClasses
                %estimate the EAE if needed
                P{z}=EnsembleAverage(X(:,:,Y==Class(z))); %(0.10)
            end
        end
        
        %%%%%%%%%%%%%%%% START COMPUTING CSPT %%%%%%%%%%%%%%%%%%%%%%%%
        %compute Sample covariance matrices for each sweep
        for k=1:size(Xnoise,3)
            %             Cs_k(:,:,k)=Xnoise(:,:,k)*Xnoise(:,:,k)'/(size(Xnoise,2)-1); %scm
            Cs_k(:,:,k)=cov(Xnoise(:,:,k)');
            %             Ct_k(:,:,k)=Xnoise(:,:,k)'*Xnoise(:,:,k)/(size(Xnoise,1)-1); %scm
            Ct_k(:,:,k)=cov(Xnoise(:,:,k));
        end
        
        %mean covariance matrices
        Cs=mean(Cs_k,3); %(0.15)
        Ct=mean(Ct_k,3); %(0.15)
        
        %%%%%%%%%%%%%%%%%%%%% BILINEAR WHITENING %%%%%%%%%%%%%%%%%%%%%%%%
        [Ux Ws]=eig(Cs); %(0.18)
        [Vx Wt]=eig(Ct); %(0.18)
        
        [Ws,ind] = sort(diag(Ws),'descend');
        sumWs=cumsum(Ws);
        indWhite1tmp=find(sumWs>max(sumWs)*(1-1e-12),1);
        % suppress only the smallest spatial eigenvectors to keep (1-1e-12)% of the
        % power of the signal
        
        if max(eigWhite1)>indWhite1tmp
            eigWhite1=1:indWhite1tmp;
        end
        if any(Ws(eigWhite1)<=0); disp('Warning negative SPATIAL eigenvalue(s)'); end
        
        Ux = Ux(:,ind);%sort spatial eigenvector
        Ux = Ux(:,eigWhite1);%whitening reduction
        [Wt,ind] = sort(diag(Wt),'descend');
        sumWt=cumsum(Wt);
        indWhite2tmp=find(sumWt>max(sumWt)*(1-1e-12),1);
        % suppress only the smallest temporal eigenvectors to keep (1-1e-12)% of the
        % power of the signal
        
        if max(eigWhite2)>indWhite2tmp
            eigWhite2=1:indWhite2tmp;
        end
        if any(Wt(eigWhite2)<=0); disp('Warning negative TEMPORAL eigenvalue(s)'); end
        
        Vx = Vx(:,ind); %sort temporal eigenvector
        Vx = Vx(:,eigWhite2);%whitening reduction
        
        Fsp = (sqrt(pinv(diag(Ws(eigWhite1)))) * Ux')'; %(0.19)
        Ft =(sqrt(pinv(diag(Wt(eigWhite2)))) * Vx')'; %(0.19)
        Gs =Ux*sqrt((diag(Ws(eigWhite1)))) ; %(0.20)
        Gt =Vx*sqrt((diag(Wt(eigWhite2)))) ; %(0.20)
        %%%%%%%%%%%%%% WHITENING MATRICES COMPUTED %%%%%%%%%%%%%%%
        
        
        %% %%%%%%%%%%%% COMPUTE CSTP FILTERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        for z=1:length(P) %for each class
            Z{z}=Fsp'*P{z}*Ft; %EAE whitening (0.22)
            [Uz{z},Wz{z},Vz{z}]=svd((Z{z})); % (0.23)
            
            %[Uz{z},Wz{z},Vz{z}]=svds((Z{z}),min(indWhite1tmp,indWhite2tmp)); % (0.23)
            
            %figure;plot(diag(Wz{z}))
            
            if exist('Pzf') %if Pzf has be given by the user (adviced)
                eigV=1:Pzf;
            else
                %%%%%%%%%%%%%% FIND OPTIMAL Pz (optional) %%%%%%%%%%%%%%
                %eigV=find(diag(Wz{z}.^2)>SNR); (0.27)
                Fdenum=norm(Z{z},'fro').^2;
                for Pz=Nbe*0.75:Nbe-1
                    
                    Uz_r{z}=Uz{z}(:,1:Pz);
                    Vz_r{z}=Vz{z}(:,1:Pz);
                    Zz=Uz_r{z}*Wz{z}(Pz,Pz)*Vz_r{z}';
                    Fnum=norm(Zz(winElec,winTime),'fro').^2;
                    indPz(Pz)=Fnum/Fdenum;
                    
                end
                [~, Pze]=max(indPz);
                eigV=1:Pze;
                %%%%%%%%%%%%%% FIND OPTIMAL Pz END (optinal) %%%%%%%%%%%%%%
            end
            
            
            if isempty(eigV) %if no optimal Pz
                eigV=1;
            end
            if max(eigV)>size(Uz{z},1) | max(eigV)>size(Vz{z},1)
                error('Subspace dimension (Pz) too high, estimated covariance matrix is lower rank. Try reduce the SubspaceDim')
            end
            Uz_r{z}=Uz{z}(:,eigV); %subspace reduction
            Vz_r{z}=Vz{z}(:,eigV); %subspace reduction
            
            
            % Compute Bs, Bt, As and At with both whitening and subspace reduction
            Bs{z}=Fsp*Uz_r{z};%Bz (0.24)
            Bt{z}=Ft*Vz_r{z};%Dz (0.24)
            As{z}=Gs* Uz_r{z}; %Az (0.24)
            At{z}=Gt* Vz_r{z}; %Ez (0.24)
            
            fullBs{z}=Fsp*Uz{z}; %only for display purpose
            fullBt{z}=Ft*Vz{z}; %only for display purpose
            fullAs{z}=Gs* Uz{z}; %only for display purpose
            fullAt{z}=Gt* Vz{z}; %only for display purpose
        end
        %topoplot_components(fullAt, fullAs,[0 1],250,9,5,'d:\tmp\') %needed to
        %check the components of the filter.
    end

    function Xw=applyCSTP(X,Bs,Bt,As,At,Y)
        if nargin<6
            Y=ones(1,size(X,3));
        end
        Classes=unique(Y);
        for k=1:size(X,3)
            c=find(Y(k)==Classes);
            Xw(:,:,k)=As{c}*Bs{c}'*X(:,:,k)*Bt{c}*At{c}';
        end
    end

    function [P Class]=EnsembleAverage(E,Y,Flash,Window,W)
        if nargin>2
            if isempty(Y)
                Y=ones(length(find(Flash)),1);
            end
            if isempty(Flash) || isempty(Window) || length(find(Flash))~=length(Y) || nargin<4
                error('Invalid Inputs in EnsembleAverage please check Flash or Window')
            end
            Xep=epoch_p300(E,Flash,Window);
            
        end
        
        if nargin<3
            Window=size(E,2);
            Xep=E;
            if nargin<2
                Y=ones(1,size(Xep,3));
            end
        end
        
        if nargin>4
            Xep=applyWeights(Xep,W);
        end
        
        
        
        
        Class=unique(Y);
        P=zeros(size(E,1),Window,length(Class));
        for z=1:length(Class)
            c=find(Y==Class(z));
            P(:,:,z)=mean(Xep(:,:,c),3);
        end
        
    end

    function [Emean Class]=meanOverlap(E,Flash,Window,TAG,Weights,doregression)
        if nargin<6 || isempty(doregression)
            doregression=1;
        end
        if nargin<5 || isempty(Weights)
            Weights=ones(length(find(Flash)),1);
        end
        
        if nargin<4 || isempty(TAG)
            TAG=ones(length(find(Flash)),1);
        end
        N=size(E,2);
        Class=unique(TAG);
        
        indFlash=find(Flash);%all Flashes (target and non-target)
        if (Window*length(Class))>1024, warning(['number of classes (' num2str(length(Class)) ') or length epochs (' num2str(Window) ' samples) are too big, cancelled regression.']);doregression=0;end
        
        %check if the trials are overlapping
        if any(indFlash(1:end-1)+Window>indFlash(2:end)) & doregression  %LS regression
            %build the weighted toeplitz matrix
            Toep=[];
            for iz=1:length(Class)
                FlashZ=zeros(N,1);
                indFZ=indFlash(TAG==Class(iz));
                FlashZ(indFZ)=Weights(TAG==Class(iz)); %include Weights in the Toeplitz matrix
                Toep=[Toep;toeplitz(zeros(1,Window),FlashZ)];% Toeplitz matrix for each class
                WeigthsCalib(iz)=(sum(Weights(TAG==Class(iz)).^2)/sum(Weights(TAG==Class(iz))));
            end
            
            Emean=E*Toep'*pinv(Toep*Toep');
            
            Emean=reshape(Emean,[size(E,1),Window,length(Class)]);
            for iz=1:length(Class)
                Emean(:,:,iz)=Emean(:,:,iz)*WeigthsCalib(iz); %(0.19) Weight correction
            end
        else %arithmetic ensemble average
            %     disp('AEA')
            indFlash=find(Flash);
            for idf=1:length(indFlash)
                epoch(:,:,idf)=E(:,indFlash(idf):indFlash(idf)+Window-1)*Weights(idf);
            end
            for iz=1:length(Class)
                Emean(:,:,iz)=mean(epoch(:,:,TAG==Class(iz)),3); %(0.19) 1/sum(Weights(TAG==Class(iz)))*
            end
        end
    end

    function [X isBad] = epoch_p300(Signal,Target,window,offset,Artefacts)
        if (nargin<5 || isempty(Artefacts))
            Artefacts=zeros(1,length(Target));
        end
        if (nargin < 4 || isempty(offset))
            offset = 0;
        end
        ixTarget = find(Target);
        while (ixTarget(end)+window-1)>size(Signal,2)
            ixTarget(end) = [];
        end
        NTarget = length(ixTarget);
        X = zeros(size(Signal,1),window,NTarget);
        isBad=zeros(1,NTarget);
        for i=1:NTarget
            X(:,:,i) = Signal(:,ixTarget(i)+offset:ixTarget(i)+window-1+offset);
            isBad(i)= length(find(Artefacts(ixTarget(i)+offset:ixTarget(i)+window-1+offset)>0));
        end
    end

    function [W,Xhatk]=WeightsEstimation(X,Y,Bs,Bt,As,At)
        
        W=ones(1,size(X,3));
        if nargin<2
            Y=ones(size(X,3),1);
        end
        Classes=unique(Y); % find all the classes
        
        if nargin<3 %%no CSTP weights (initialization)
            for k=1:size(X,3) % for each epoch
                W(k)=1/norm(X(:,:,k),'fro'); %compute the initilized weights
            end
        else
            Xhatk=zeros(size(X));
            for k=1:size(X,3) % for each epoch
                %                 Xk=X(:,:,k);
                c=(Y(k)==Classes); % class of the current epoch
                Xhatk(:,:,k)=As{c}*Bs{c}'*X(:,:,k)*Bt{c}*At{c}'; % signal estimation
                W(k)=norm(Xhatk(:,:,k) ,'fro')/norm( X(:,:,k)-Xhatk(:,:,k),'fro'); % SNR estimation
            end
            
        end
        % Weights normalization
        for z=1:length(Classes) % for each class
            Wz=W(Y==Classes(z));
            W(Y==Classes(z))=length(Wz)*Wz/sum(Wz); % normalize each class weights
        end
    end

    function FlashCorrected=CorrectLatency(Flash,Latencies,RND)
        if nargin<3
            RND=1:length(find(Flash)); %no random seed
        end
        if size(Flash,1) == 1, Flash = Flash'; end;
        FlashCorrected=zeros(size(Flash));
        indF=find(Flash);
        if length(indF)~=Latencies
            indF(RND)=indF(RND)+Latencies;
            indFcorrected=indF;
        else
            indFcorrected=indF+Latencies;
        end
        FlashCorrected(indFcorrected)=1;
    end

    function Conv=ConvergenceLatencies(Lat1,Lat2)
        Conv=mean(abs(Lat1-Lat2));
    end

    function [Latency Crit_TraceN]=LatencyEstimation(Xall,X,Y,W,Bs,Bt,As,At,winElec,winTime)
        
        WindowSize=size(X,2);
        SizeMax=size(Xall,2);
        finalInd=SizeMax-WindowSize;
        delay0=floor(finalInd/2)+1;
        if nargin<3
            Y=ones(size(X,3),1);
        end
        if nargin<4
            W=ones(size(Y));
        end
        Xweighted=applyWeights(X,W);
        Xallw=applyWeights(Xall,W);
        Classes=unique(Y);
        
        if nargin<5 || isempty(Bs)
            for i=1:length(Classes)
                Bs{i}=eye(size(X,1));
                Bt{i}=eye(size(X,2));
            end
        end
        if nargin<7 || isempty(As)
            for i=1:length(Classes)
                
                As{i}=eye(size(X,1));
                At{i}=eye(size(X,1));
            end
        end
        if nargin<9
            winElec=1:size(X,1);
        end
        if nargin<10
            winTime=1:size(X,2);
        end
        
        for k=1:size(Xall,3)
            
            z=find(Classes==Y(k));
            Xother=Xweighted(:,:,[1:k-1 k+1:end]);
            Tag=Y([1:k-1 k+1:end]);
            Xother=Xother(:,:,Tag==Classes(z));
            Pother=mean(Xother,3); %P300 estimation
            Ybar=Bs{z}'*Pother*Bt{z};
            %Xbar=As{z}*Ybar*At{z}';
            
            %%%%%%% WARNING : this part need to be optimize %%%%%%%%%%%%%%%%%%%%%%%
            for lat=1:finalInd+1
                Xtmp=Xallw(:,lat:lat+WindowSize-1,k);
                Xwk=zeros(size(Xtmp));
                Xwk(winElec,winTime)=Xtmp(winElec,winTime);
                Yk=Bs{z}'*Xwk*Bt{z};
                %Xk=As{z}*Yk*At{z}';
                
                Criterion_Trace(k,lat)=trace(Ybar*Yk');
            end
            %%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            
            Crit_TraceN(k,:)=Criterion_Trace(k,:)-min(Criterion_Trace(k,:));%normalize criteria
            [Pik Peaks]=findpeaks(Crit_TraceN(k,:)); %criteria
            
            if isempty(Peaks)
                Peaks=delay0;
            else
                indP=find(Pik>max(Pik)*0.66); %accept only peak of 66% of max (heuristic criteria)
                Peaks=Peaks(indP);
            end
            
            
            [trash IndM]=min(abs(Peaks-delay0)); %choose closest peak from allowed ones
            Latency(k)=Peaks(IndM)-delay0;
            
        end
        
        Latency=Latency';
        
    end

    function [Pzind SNR]=best_Pz(Zbarz,Electrodes,Window,indClass)
        % it is important that the Pz are sorted in descend order
        if nargin<4
            indClass=size(Zbarz{1},3); %take the "target" class that should be the last
        end
        for i=1:length(Zbarz)
            noise=Zbarz{i}(:,:,indClass);
            signal=noise(Electrodes,Window);
            SNR(i)=norm(signal,'fro')/norm(noise,'fro');
        end
         SNR = smooth(SNR,3);%EXPERIMENTAL : smooth SNR (moving average 3 points) 
         SNR=SNR-min(SNR);
        if length(Zbarz)>3 & length(unique(SNR))>1
            [maxs INDtmp]=findpeaks(SNR);
           
            plot(SNR);hold on;plot(INDtmp,maxs,'ro')
            
        else
            INDtmp=[];
        end
        [tmpPz Pzind]=max(SNR(2:end-1));Pzind=Pzind+1;%EXPERIMENTAL : remove the first and last for the computation of the maximum

        if ~isempty(INDtmp)
            IND=INDtmp(maxs>(tmpPz*0.66));
            if ~isempty(IND)
                Pzind=IND(1);%take the greatest valid Pz
            end
        end
        
        %check that you don't take the maximum or minimum Pz
        if length(Zbarz)>=3
            if Pzind==length(Zbarz),Pzind=Pzind-1;end
            if Pzind==1,Pzind=Pzind+1;end
        end
        
    end

    function printCurrentState(INFO,previousLine)
        if nargin<2
            previousLine=true;
        end
        str = [sprintf(INFO)];
        if previousLine
            str = [sprintf(char(repmat(double('\b'),1,length(str)+1))) str];
        end
        disp(str);
    end

    function Xw=applyWeights(X,W)
        
        for k=1:length(W)
            Xw(:,:,k)=X(:,:,k)*W(k);
        end
        
    end

end
##### SOURCE END #####
--></body></html>